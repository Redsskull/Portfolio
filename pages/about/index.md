# About

## Nathaniel Ivry ðŸ‡¸ðŸ‡ª

## The Long Way Around

I spent my 20s and 30s training to become a commercial pilot. I earned my ATPL and CFA and learned what it means to operate inside safety-critical systems where mistakes compound quickly.

At 35, recurring kidney stones ended my medical certification â€” and with it, my entire career.

After the loss, I rebuilt.

I installed Arch Linux, picked up Brian Kernighan (UNIX: A History and a Memoir), and started learning how computers actually work.

A web-focused bootcamp didn't click. HTML and CSS felt like the *surface* of something much deeper.

Then I found CS50.

That's where I realized programming isn't about writing code â€” it's about **designing systems**, reasoning about constraints, and making trade-offs under pressure.

When I finally solved Tideman after two weeks of failure, I knew I wasn't just learning syntax. I was doing systems thinking, connecting the dots. I was having fun.

---

## Why Backend Engineering Fits Me

**Aviation Trained Me for Operations**

Flying is systems responsibility in real time: checklists, redundancy, failure modes, and calm decision-making when things don't go as planned. Backend engineering felt familiar immediately â€” designing systems that handle failure gracefully, thinking through edge cases, and building for reliability under real-world constraints.

**Distributed Systems Felt Like Home**

I grew up on IRC, Usenet, and early online communities. My first computer (well, my father's) was an LC475 that I was very upset with because it could not play my friends' games. Still, I watched in awe as he navigated a network that was very new at the time, and as I grew to understand programming more, I realized that even today in 2026, the network is still fascinating. I want to program in it.

**Rebuilding Taught Me Resilience**

Learning to program while managing chronic pain taught me the power of routine. I had it before to even become a pilot, but doing it while under duress and pain really showed me how fixing one thing every day can add up to a mountain.

---

## How I Think

I respect frontend specialists and UI craftsmanship deeply. As a matter of fact, I'd love to be good at it someday. My strength is elsewhere: **backend systems, automation, and operational reliability**.

Programs solve a problem for someone somewhere, and computers are always ultimately an extension of our own thinking. If I care about the problem deeply, my solution will be a good one.

---

## What I Build and Operate

* Backend services and APIs
* Distributed and concurrent systems
* Automation tooling and scripts
* Production deployments and environments
* Systems that fail predictably and recover cleanly

---

## Tools & Stack

**Primary:**  
Go (concurrency & systems)  
Python (data & automation)  
Ruby (expressiveness & CLI tools)  
Bash (glue & ops)  
Podman (containers & reproducibility)

**Actively Learning:**  
Distributed systems theory  
Service orchestration  
Observability and reliability patterns  
Infrastructure as code concepts

---

## Where I'm Headed

I'm looking for **junior backend engineering roles** where:

* Reliability matters
* Curiosity is valued
* Learning happens in production
* Experience is measured in judgment, not years

I bring maturity, systems thinking, and respect for operational reality.

---

## Connect

* **GitHub:** <a href="https://github.com/Redsskull" target="_blank" rel="noopener noreferrer">github.com/Redsskull</a>
* **LinkedIn:** <a href="https://www.linkedin.com/in/nathanielivry" target="_blank" rel="noopener noreferrer">linkedin.com/in/redsskull</a>
* **Portfolio:** <a href="https://nathanielivry.dev" target="_blank" rel="noopener noreferrer">nathanielivry.dev</a>

---

*I rebuilt once. I know how to learn fast, think in systems, and keep things running when it matters.*
